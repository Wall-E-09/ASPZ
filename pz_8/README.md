# ASPZ
Завдання 8.1
 Чи може виклик count = write(fd, buffer, nbytes); повернути в змінній count значення, відмінне від nbytes? Якщо так, то чому? Наведіть робочий приклад програми, яка демонструє вашу відповідь.

![image](https://github.com/user-attachments/assets/23fc4ac0-0322-4447-9ccd-ed43621696a4)
Так, виклик write() може повернути значення, відмінне від nbytes. Це може статися через:
Недостатній простір на диску - система не може записати всі даніОбмеження RLIMIT_FSIZE - досягнуто ліміт розміру файлуСигнали (наприклад, SIGINTR) - переривання системного викликуПовний pipe buffer - при записі в pipe/каналАпаратні помилки - проблеми з носієм даних


Завдання 8.2
 Є файл, дескриптор якого — fd. Файл містить таку послідовність байтів: 4, 5, 2, 2, 3, 3, 7, 9, 1, 5. У програмі виконується наступна послідовність системних викликів:
lseek(fd, 3, SEEK_SET);
read(fd, &buffer, 4);
де виклик lseek переміщує покажчик на третій байт файлу. Що буде містити буфер після завершення виклику read? Наведіть робочий приклад програми, яка демонструє вашу відповідь.
![image](https://github.com/user-attachments/assets/4017a041-2723-4e4c-bcf8-81b237d908df)
Початковий вміст файлу (індексація з 0):
Позиція: 0 1 2 3 4 5 6 7 8 9
Значення: 4 5 2 2 3 3 7 9 1 5
lseek(fd, 3, SEEK_SET) переміщує покажчик на 3-йй байт (значення 2)
read(fd, &buffer, 4) читає 4 байти, починаючи з позиції 3
Буфер міститиме послідовність байтів з позицій 3-6:
buffer[0] = 2 (поз.3)
buffer[1] = 3 (поз.4)
buffer[2] = 3 (поз.5)
buffer[3] = 7 (поз.6)


Завдання 8.3
 Бібліотечна функція qsort призначена для сортування даних будь-якого типу. Для її роботи необхідно підготувати функцію порівняння, яка викликається з qsort кожного разу, коли потрібно порівняти два значення.
 Оскільки значення можуть мати будь-який тип, у функцію порівняння передаються два вказівники типу void* на елементи, що порівнюються.
Напишіть програму, яка досліджує, які вхідні дані є найгіршими для алгоритму швидкого сортування. Спробуйте знайти кілька масивів даних, які змушують qsort працювати якнайповільніше. Автоматизуйте процес експериментування так, щоб підбір і аналіз вхідних даних виконувалися самостійно.
Придумайте і реалізуйте набір тестів для перевірки правильності функції qsort.

![image](https://github.com/user-attachments/assets/7c20a973-c300-491a-a20f-266257e758bb)

Найгірші випадки для qsort:
Вже відсортований масив (O(n²) при виборі поганого опорного елемента)
Масив з однаковими елементами (погане розбиття)
Зворотно відсортований масив (найгірший випадок для naive pivot
Спеціально підібрані "killersequence" (для конкретних реалізацій)
Сучасні реалізації qsort використовують оптимізації:
Median-of-three для вибору pivot
Перехід на heapsort при глибині рекурсії > 2log(n)
Інтроспективне сортування








Завдання 8.4
 Виконайте наступну програму на мові програмування С:
int main() {
  int pid;
  pid = fork();
  printf("%d\n", pid);
}
Завершіть цю програму. Припускаючи, що виклик fork() був успішним, яким може бути результат виконання цієї програми?

![image](https://github.com/user-attachments/assets/89141eb2-232f-47b1-b3f1-fc0b33e9f215)

 Механізм роботи fork():
Створює повну копію процесу (батьківський → дочірній)
У батьківському процесі повертає PID дочірнього процесу
У дочірньому процесі повертає 0
При помилці повертає -1 (у нашому випадку припускаємо успішний виклик)






Проведіть тестування: що буде, якщо виконати fork() усередині циклу for із затримкою між викликами?
![image](https://github.com/user-attachments/assets/f0e1c37d-e3c4-4a4b-b990-f1df9d3a2229)
 Дерево процесів, що утворюється:
Створюється 8 процесів загалом (2^n, де n=3 ітерації)
Кожна ітерація циклу подвоює кілкість активних процесів
Глибина дерева процесів - 3 рівні
Експоненційне зростання: Кожен дочірній процес продовжує виконання циклу
Затримки (sleep): Синхронізують вивід, але не впливають на логіку розгалуження
Порядок виводу: Не детрмінований через паралельне виконання
Зомбі-процеси: Утворюються тимчасово до виклику wait()
