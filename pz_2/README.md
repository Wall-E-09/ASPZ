# ASPZ

2.1
1. Напишіть програму для визначення моменту, коли time_t
закінчиться.Дослідіть, які зміни відбуваються в залежності від 32- та
64-бітної архітектури. Дослідіть сегменти виконуваного файлу.
![image](https://github.com/user-attachments/assets/1aecf369-cfc9-4717-b7ca-4fd3cb507e47)
![image](https://github.com/user-attachments/assets/41a812bd-7d9a-4cff-9dad-c5ecd73839f6)
Функція analyze_time_t визначає розмір time_t (4 або 8 байт), виводить його максимальне значення та відповідну дату (за допомогою ctime), демонструючи обмеження 32-бітних систем (проблема "2038 року").

Аналіз сегментів пам’яті:
Функція analyze_memory_segments виводить адреси глобальних (data), статичних (BSS), та локальних (стек) змінних, показуючи, як компілятор розподіляє пам’ять.


2.2
Розгляньте сегменти у виконуваному файлі.
1. Скомпілюйте програму &quot;hello world&quot;, запустіть ls -l для
виконуваного файлу, щоб отримати його загальний розмір, і
запустіть size, щоб отримати розміри сегментів всередині нього.
2. Додайте оголошення глобального масиву із 1000 int,
перекомпілюйте й повторіть вимірювання. Зверніть увагу на
відмінності.
3. Тепер додайте початкове значення в оголошення масиву
(пам’ятайте, що C не змушує вас вказувати значення для кожного
елемента масиву в ініціалізаторі). Це перемістить масив із сегмента

BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на
різницю.
4. Тепер додайте оголошення великого масиву в локальну функцію.
Оголосіть другий великий локальний масив з ініціалізатором.
Повторіть вимірювання. Дані розташовуються всередині функцій,
залишаючись у виконуваному файлі? Яка різниця, якщо масив
ініціалізований чи ні?
5. Які зміни відбуваються з розмірами файлів і сегментів, якщо ви
компілюєте для налагодження? Для максимальної оптимізації?
![image](https://github.com/user-attachments/assets/71eb2a39-24ca-4360-a0f7-967458ff7a3a)
stage1 виводить повідомлення "Hello, world!" та не використовує додаткову пам’ять.

stage2 оголошує неініціалізований глобальний масив (global_array), який потрапляє у BSS-сегмент (пам’ять під нього виділяється при запуску програми).

stage3 оголошує частково ініціалізований глобальний масив (global_init_array), який потрапляє у сегмент даних (data).

stage4 демонструє локальні масиви у стеку, виводячи їх адреси.

2.3
Завдання 2.3.
Скомпілюйте й запустіть тестову програму, щоб визначити приблизне
розташування стека у вашій системі:
#include &lt;stdio.h&gt;
int main() {
int i;
printf(&quot;The stack top is near %p\n&quot;, &amp;i);
return 0;
}


![image](https://github.com/user-attachments/assets/68cf3ca4-b86c-4a49-aa44-fd964d822c91)

Сегменти пам'яті:

У main() виводяться адреси змінних з різних сегментів:

Text segment (адреса функції main)

Data segment (ініціалізовані глобальні та статичні змінні)

BSS segment (неініціалізовані глобальні та статичні змінні)

Heap (динамічно виділена пам'ять через malloc)

Stack (локальні змінні функцій)




2.4
Ваше завдання – дослідити стек процесу або пригадати, як це робиться. Ви
можете:
● Автоматично за допомогою утиліти gstack.
● Вручну за допомогою налагоджувача GDB.
Користувачі Ubuntu можуть зіткнутися з проблемою: на момент написання
(Ubuntu 18.04) gstack, схоже, не був доступний (альтернативою може бути
pstack). Якщо gstack не працює, використовуйте другий метод – через
GDB, як показано нижче.

![image](https://github.com/user-attachments/assets/dc669ed8-878d-4d0b-a161-8aee2de5dc34)

Програма виводить адреси локальних змінних у різних функціях, демонструючи, як стек зростає вниз (адреси зменшуються) при кожному новому виклику функції

Використовується макрос MSG для єдиного формату виводу інформації про функцію та адресу її локальної змінної




2.5

Відомо, що при виклику процедур і поверненні з них процесор
використовує стек.Чи можна в такій схемі обійтися без лічильника команд
(IP), використовуючи замість нього вершину стека? Обґрунтуйте свою
відповідь та наведіть приклади.


![image](https://github.com/user-attachments/assets/43fc8435-0ed4-4a0b-b75a-b3584df74bea)

Адреси у стеку:

Вивід адреси змінної x у func2() демонструє типове розташування даних у стеку

Виклик func1() з func2() показує, як працює механізм повернення з функцій


2.9
Дослідіть використання сегмента BSS для збереження великих
масивів.
![image](https://github.com/user-attachments/assets/30b1dd22-e8d9-433e-8fe2-4d5fd4bdac95)
Масив global_array розміром 1 мільйон int (близько 4 МБ для 32-бітних систем) оголошений як глобальна неініціалізована змінна

Такий масив автоматично розміщується у сегменті BSS, який:

Використовується для неініціалізованих глобальних і статичних змінних

Заповнюється нулями при запуску програми

Не збільшує розмір виконуваного файлу (на відміну від сегмента даних)
